package javafixes.object.changing;

import javafixes.common.function.TriFunction;
import javafixes.common.function.ValueHandler;
import javafixes.common.function.ValueMapper;
import javafixes.object.Value;
import javafixes.object.changing.builder.CachedValueBuilder;
import javafixes.object.changing.builder.DerivedJoinedValueBuilder;
import javafixes.object.changing.builder.DerivedValueBuilder;
import javafixes.object.changing.function.mapping.FailableValueMapper;

import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Function;

import static javafixes.object.changing.builder.CachedValueBuilder.cachedValueBuilder;
import static javafixes.object.changing.builder.DerivedValueBuilder.derivedValue;
import static javafixes.object.changing.builder.DerivedValueBuilder.derivedValueBuilder;
import static javafixes.object.changing.util.ChangingValueUtil.joiningValues;

/**
 * {@link ChangingValue} is intended as wrapper of value that could change over time and whose changes should propagate
 * to other values derived from it automatically.
 * <p>
 * <p>A good usage example would be a config from which other values could be derived and should be changed
 * once config changes.
 *
 * @param <T> type of wrapped value
 * @author mtymes
 */
// todo: mtymes - add javadoc to all implementations
public interface ChangingValue<T> extends Value<T> {

    /**
     * @return optional name of {@link ChangingValue}
     */
    Optional<String> name();

    /**
     * Provides currently wrapped value with its change version number
     *
     * @return current {@link ChangingValue}'s wrapped {@link VersionedValue}
     */
    VersionedValue<T> versionedValue();

    /**
     * @return current {@link ChangingValue}'s wrapped value
     * @throws RuntimeException in case the wrapped value is a failure
     */
    @Override
    default T value() {
        return versionedValue().value();
    }

    /**
     * Indicator of how often has the wrapped value changed since initialization.
     * Should be 0 when value is created and each time the underlying value changes the {@code changeVersion} should
     * increase by one.
     *
     * @return number indicator of how many times has the wrapped value changed
     */
    default long changeVersion() {
        return versionedValue().versionNumber;
    }

    /**
     * @return current {@link ChangingValue}'s wrapped {@link FailableValue}
     */
    default FailableValue<T> failableValue() {
        return versionedValue().failableValue();
    }

    // current functions

    /**
     * Generates a value using the current {@link ChangingValue}'s wrapped {@link FailableValue}
     *
     * @param valueMapper function that is applied to currently wrapped {@link FailableValue}
     * @param <T2>        type of generated value
     * @param <E>         {@link Throwable} type, in case the {@code valueMapper} function should throw an {@link Throwable}
     * @return generated value
     * @throws E exception generated by {@code valueMapper} function
     */
    default <T2, E extends Throwable> T2 mapCurrent(ValueMapper<FailableValue<T>, ? extends T2, E> valueMapper) throws E {
        return valueMapper.map(failableValue());
    }

    /**
     * Generates a value using the current {@link ChangingValue}'s wrapped value
     *
     * @param valueMapper function that is applied to currently wrapped value
     * @param <T2>        type of generated value
     * @param <E>         {@link Throwable} type, in case the {@code valueMapper} function should throw an {@link Throwable}
     * @return generated value
     * @throws E exception generated by {@code valueMapper} function
     */
    default <T2, E extends Throwable> T2 mapCurrentValue(ValueMapper<? super T, ? extends T2, E> valueMapper) throws E {
        return valueMapper.map(value());
    }

    /**
     * Executes {@code valueHandler} function for currently wrapped {@link FailableValue}
     *
     * @param valueHandler function that is executed for currently wrapped {@link FailableValue}
     * @param <E>          {@link Throwable} type, in case the {@code valueHandler} function should throw an {@link Throwable}
     * @throws E exception generated by {@code valueHandler} function
     */
    default <E extends Throwable> void forCurrent(ValueHandler<FailableValue<T>, ? extends E> valueHandler) throws E {
        valueHandler.handle(failableValue());
    }

    /**
     * Executes {@code valueHandler} function for currently wrapped value
     *
     * @param valueHandler function that is executed for currently wrapped value
     * @param <E>          {@link Throwable} type, in case the {@code valueHandler} function should throw an {@link Throwable}
     * @throws E exception generated by {@code valueHandler} function
     */
    default <E extends Throwable> void forCurrentValue(ValueHandler<? super T, ? extends E> valueHandler) throws E {
        valueHandler.handle(value());
    }

    // map functions

    /**
     * Creates a derived {@link ChangingValue} of type {@link DerivedValue}.
     * The derived value provides the outcome of {@code valueMapper} applied to the latest wrapped {@link FailableValue}.
     * Call to this operation does not change the state of this {@link ChangingValue}.
     *
     * @param valueMapper function to map the wrapped value into a new one
     * @param <T2>        the type of value wrapped by the {@link DerivedValue}
     * @return new {@link DerivedValue} that provides a value derived from this {@link ChangingValue}
     */
    default <T2> DerivedValue<T2> map(FailableValueMapper<T, T2> valueMapper) {
        return derivedValue(this, valueMapper);
    }

    /**
     * Creates a derived {@link ChangingValue} of type {@link DerivedValue}.
     * The derived value provides the outcome of {@code valueMapper} applied to the latest wrapped value.
     * In case this {@link ChangingValue} doesn't wrap expected value of type {@link T} but a failure/{@link RuntimeException}
     * instead, this {@link RuntimeException} will be propagated as a wrapped value of the newly generated {@link DerivedValue}.
     * Call to this operation does not change the state of this {@link ChangingValue}.
     *
     * @param valueMapper function to map the wrapped value into a new one
     * @param <T2>        the type of value wrapped by the {@link DerivedValue}
     * @return new {@link DerivedValue} that provides a value derived from this {@link ChangingValue}
     */
    default <T2> DerivedValue<T2> mapValue(Function<? super T, ? extends T2> valueMapper) {
        return derivedValue(this, FailableValueMapper.value(valueMapper));
    }

    /**
     * Creates a builder of derived {@link ChangingValue} of type {@link DerivedValueBuilder}.
     * The builder applies the {@code valueMapper} to the latest wrapped {@link FailableValue}.
     * Call to this operation does not change the state of this {@link ChangingValue}.
     *
     * @param valueMapper function to map the wrapped value into a new one
     * @param <T2>        the type of value wrapped by the build {@link DerivedValue}
     * @return new {@link DerivedValueBuilder} that provides a value derived from this {@link ChangingValue}
     */
    default <T2> DerivedValueBuilder<T2> mapBuilder(FailableValueMapper<T, T2> valueMapper) {
        return derivedValueBuilder(this, valueMapper);
    }

    /**
     * Creates a builder of derived {@link ChangingValue} of type {@link DerivedValueBuilder}.
     * The builder applies the {@code valueMapper} to the latest wrapped value.
     * In case this {@link ChangingValue} doesn't wrap expected value of type {@link T} but a failure/{@link RuntimeException}
     * instead, this {@link RuntimeException} will be propagated as a wrapped value of the newly generated {@link DerivedValue}.
     * Call to this operation does not change the state of this {@link ChangingValue}.
     *
     * @param valueMapper function to map the wrapped value into a new one
     * @param <T2>        the type of value wrapped by the build {@link DerivedValue}
     * @return new {@link DerivedValueBuilder} that provides a value derived from this {@link ChangingValue}
     */
    default <T2> DerivedValueBuilder<T2> mapValueBuilder(Function<? super T, ? extends T2> valueMapper) {
        return derivedValueBuilder(this, FailableValueMapper.value(valueMapper));
    }

    // join functions

    /**
     * Creates a derived {@link ChangingValue} of type {@link DerivedJoinedValue} by aggregating this {@link ChangingValue} with one another {@link ChangingValue}.
     * The derived value provides the outcome of {@code mapFunction} to the latest set of wrapped {@link FailableValue}s.
     * Call to this operation does not change the state of this or the other provided {@link ChangingValue}.
     *
     * @param value2 second {@link ChangingValue} that goes into the mapFunction
     * @param mapFunction function to map wrapped values into a new one
     * @return new {@link DerivedJoinedValue} that provides a value derived from supplied {@link ChangingValue}s
     * @param <T2> type of the second {@link ChangingValue} that goes into the mapFunction
     * @param <OutputType> the type of value wrapped by the {@link DerivedJoinedValue}
     */
    default <T2, OutputType> DerivedJoinedValue<OutputType> join(
            ChangingValue<T2> value2,
            BiFunction<FailableValue<T>, FailableValue<T2>, OutputType> mapFunction
    ) {
        return DerivedJoinedValueBuilder.join(this, value2, mapFunction);
    }

    /**
     * Creates a derived {@link ChangingValue} of type {@link DerivedJoinedValue} by aggregating this {@link ChangingValue} with two other {@link ChangingValue}s.
     * The derived value provides the outcome of {@code mapFunction} to the latest set of wrapped {@link FailableValue}s.
     * Call to this operation does not change the state of this or any other provided {@link ChangingValue}s.
     *
     * @param value2 second {@link ChangingValue} that goes into the mapFunction
     * @param value3 third {@link ChangingValue} that goes into the mapFunction
     * @param mapFunction function to map wrapped values into a new one
     * @return new {@link DerivedJoinedValue} that provides a value derived from supplied {@link ChangingValue}s
     * @param <T2> type of the second {@link ChangingValue} that goes into the mapFunction
     * @param <T3> type of the third {@link ChangingValue} that goes into the mapFunction
     * @param <OutputType> the type of value wrapped by the {@link DerivedJoinedValue}
     */
    default <T2, T3, OutputType> DerivedJoinedValue<OutputType> join(
            ChangingValue<T2> value2,
            ChangingValue<T3> value3,
            TriFunction<FailableValue<T>, FailableValue<T2>, FailableValue<T3>, OutputType> mapFunction
    ) {
        return DerivedJoinedValueBuilder.join(this, value2, value3, mapFunction);
    }

    /**
     * Creates a derived {@link ChangingValue} of type {@link DerivedJoinedValue} by aggregating this {@link ChangingValue} with one another {@link ChangingValue}.
     * The derived value provides the outcome of {@code mapFunction} to the latest set of wrapped values.
     * In case any {@link ChangingValue} doesn't wrap expected value of defined type but a failure/{@link RuntimeException}
     * instead, the first {@link RuntimeException} will be propagated as a wrapped value of the newly generated {@link DerivedJoinedValue}.
     * Call to this operation does not change the state of this or the other provided {@link ChangingValue}.
     *
     * @param value2 second {@link ChangingValue} that goes into the mapFunction
     * @param mapFunction function to map wrapped values into a new one
     * @return new {@link DerivedJoinedValue} that provides a value derived from supplied {@link ChangingValue}s
     * @param <T2> type of the second {@link ChangingValue} that goes into the mapFunction
     * @param <OutputType> the type of value wrapped by the {@link DerivedJoinedValue}
     */
    default <T2, OutputType> DerivedJoinedValue<OutputType> joinValues(
            ChangingValue<T2> value2,
            BiFunction<T, T2, OutputType> mapFunction
    ) {
        return DerivedJoinedValueBuilder.join(this, value2, joiningValues(mapFunction));
    }

    /**
     * Creates a derived {@link ChangingValue} of type {@link DerivedJoinedValue} by aggregating this {@link ChangingValue} with two other {@link ChangingValue}s.
     * The derived value provides the outcome of {@code mapFunction} to the latest set of wrapped values.
     * In case any {@link ChangingValue} doesn't wrap expected value of defined type but a failure/{@link RuntimeException}
     * instead, the first {@link RuntimeException} will be propagated as a wrapped value of the newly generated {@link DerivedJoinedValue}.
     * Call to this operation does not change the state of this or any other provided {@link ChangingValue}s.
     *
     * @param value2 second {@link ChangingValue} that goes into the mapFunction
     * @param value3 third {@link ChangingValue} that goes into the mapFunction
     * @param mapFunction function to map wrapped values into a new one
     * @return new {@link DerivedJoinedValue} that provides a value derived from supplied {@link ChangingValue}s
     * @param <T2> type of the second {@link ChangingValue} that goes into the mapFunction
     * @param <T3> type of the third {@link ChangingValue} that goes into the mapFunction
     * @param <OutputType> the type of value wrapped by the {@link DerivedJoinedValue}
     */
    default <T2, T3, OutputType> DerivedJoinedValue<OutputType> joinValues(
            ChangingValue<T2> value2,
            ChangingValue<T3> value3,
            TriFunction<T, T2, T3, OutputType> mapFunction
    ) {
        return DerivedJoinedValueBuilder.join(this, value2, value3, joiningValues(mapFunction));
    }

    /**
     * Creates a builder of derived {@link ChangingValue} of type {@link DerivedJoinedValueBuilder} by aggregating this {@link ChangingValue} with one another {@link ChangingValue}.
     * The builder applies the {@code mapFunction} to the latest set of wrapped {@link FailableValue}s.
     * Call to this operation does not change the state of this or the other provided {@link ChangingValue}.
     *
     * @param value2 second {@link ChangingValue} that goes into the mapFunction
     * @param mapFunction function to map wrapped values into a new one
     * @return new {@link DerivedJoinedValueBuilder} that provides a value derived from supplied {@link ChangingValue}s
     * @param <T2> type of the second {@link ChangingValue} that goes into the mapFunction
     * @param <OutputType> the type of value wrapped by the {@link DerivedJoinedValueBuilder}
     */
    default <T2, OutputType> DerivedJoinedValueBuilder<OutputType> joinBuilder(
            ChangingValue<T2> value2,
            BiFunction<FailableValue<T>, FailableValue<T2>, OutputType> mapFunction
    ) {
        return DerivedJoinedValueBuilder.joinBuilder(this, value2, mapFunction);
    }

    /**
     * Creates a builder of derived {@link ChangingValue} of type {@link DerivedJoinedValueBuilder} by aggregating this {@link ChangingValue} with two other {@link ChangingValue}s.
     * The builder applies the {@code mapFunction} to the latest set of wrapped {@link FailableValue}s.
     * Call to this operation does not change the state of this or any other provided {@link ChangingValue}s.
     *
     * @param value2 second {@link ChangingValue} that goes into the mapFunction
     * @param value3 third {@link ChangingValue} that goes into the mapFunction
     * @param mapFunction function to map wrapped values into a new one
     * @return new {@link DerivedJoinedValueBuilder} that provides a value derived from supplied {@link ChangingValue}s
     * @param <T2> type of the second {@link ChangingValue} that goes into the mapFunction
     * @param <T3> type of the third {@link ChangingValue} that goes into the mapFunction
     * @param <OutputType> the type of value wrapped by the {@link DerivedJoinedValueBuilder}
     */
    default <T2, T3, OutputType> DerivedJoinedValueBuilder<OutputType> joinBuilder(
            ChangingValue<T2> value2,
            ChangingValue<T3> value3,
            TriFunction<FailableValue<T>, FailableValue<T2>, FailableValue<T3>, OutputType> mapFunction
    ) {
        return DerivedJoinedValueBuilder.joinBuilder(this, value2, value3, mapFunction);
    }

    /**
     * Creates a builder of derived {@link ChangingValue} of type {@link DerivedJoinedValueBuilder} by aggregating this {@link ChangingValue} with one another {@link ChangingValue}.
     * The builder applies the {@code mapFunction} to the latest set of wrapped values.
     * In case any {@link ChangingValue} doesn't wrap expected value of defined type but a failure/{@link RuntimeException}
     * instead, the first {@link RuntimeException} will be propagated as a wrapped value of the newly generated {@link DerivedJoinedValue}.
     * Call to this operation does not change the state of this or the other provided {@link ChangingValue}.
     *
     * @param value2 second {@link ChangingValue} that goes into the mapFunction
     * @param mapFunction function to map wrapped values into a new one
     * @return new {@link DerivedJoinedValueBuilder} that provides a value derived from supplied {@link ChangingValue}s
     * @param <T2> type of the second {@link ChangingValue} that goes into the mapFunction
     * @param <OutputType> the type of value wrapped by the {@link DerivedJoinedValueBuilder}
     */
    default <T2, OutputType> DerivedJoinedValueBuilder<OutputType> joinValuesBuilder(
            ChangingValue<T2> value2,
            BiFunction<T, T2, OutputType> mapFunction
    ) {
        return DerivedJoinedValueBuilder.joinBuilder(this, value2, joiningValues(mapFunction));
    }

    /**
     * Creates a builder of derived {@link ChangingValue} of type {@link DerivedJoinedValueBuilder} by aggregating this {@link ChangingValue} with two other {@link ChangingValue}s.
     * The builder applies the {@code mapFunction} to the latest set of wrapped values.
     * In case any {@link ChangingValue} doesn't wrap expected value of defined type but a failure/{@link RuntimeException}
     * instead, the first {@link RuntimeException} will be propagated as a wrapped value of the newly generated {@link DerivedJoinedValue}.
     * Call to this operation does not change the state of this or any other provided {@link ChangingValue}s.
     *
     * @param value2 second {@link ChangingValue} that goes into the mapFunction
     * @param value3 third {@link ChangingValue} that goes into the mapFunction
     * @param mapFunction function to map wrapped values into a new one
     * @return new {@link DerivedJoinedValueBuilder} that provides a value derived from supplied {@link ChangingValue}s
     * @param <T2> type of the second {@link ChangingValue} that goes into the mapFunction
     * @param <T3> type of the third {@link ChangingValue} that goes into the mapFunction
     * @param <OutputType> the type of value wrapped by the {@link DerivedJoinedValueBuilder}
     */
    default <T2, T3, OutputType> DerivedJoinedValueBuilder<OutputType> joinValuesBuilder(
            ChangingValue<T2> value2,
            ChangingValue<T3> value3,
            TriFunction<T, T2, T3, OutputType> mapFunction
    ) {
        return DerivedJoinedValueBuilder.joinBuilder(this, value2, value3, joiningValues(mapFunction));
    }

    // cache functions

    /**
     * Creates a {@link CachedValueBuilder} derived from this {@link ChangingValue}
     * @return derived {@link CachedValueBuilder}
     */
    default CachedValueBuilder<T> cacheBuilder() {
        return cachedValueBuilder(this);
    }
}
