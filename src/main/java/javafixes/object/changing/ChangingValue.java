package javafixes.object.changing;

import javafixes.common.function.ValueHandler;
import javafixes.common.function.ValueMapper;
import javafixes.object.Value;

import java.util.Optional;

/**
 * {@code ChangingValue} is intended as wrapper of value that could change over time and whose changes should propagate
 * to other values derived from it automatically.
 * <p>
 * <p>A good usage example would be a config from which other values could be derived and should be changed
 * once config changes.
 *
 * @param <T> type of wrapped value
 * @author mtymes
 */
// todo: mtymes - add javadoc to all implementations
public interface ChangingValue<T> extends Value<T> {

    /**
     * @return optional name of {@code ChangingValue}
     */
    Optional<String> name();

    /**
     * Provides currently wrapped value with its change version number
     *
     * @return current {@code ChangingValue}'s wrapped {@code VersionedValue}
     */
    VersionedValue<T> versionedValue();

    /**
     * @return current {@code ChangingValue}'s wrapped value
     * @throws RuntimeException in case the wrapped value is a failure
     */
    @Override
    default T value() {
        return versionedValue().value();
    }

    /**
     * Indicator of how often has the wrapped value changed since initialization.
     * Should be 0 when value is created and each time the underlying value changes the {@code changeVersion} should
     * increase by one.
     *
     * @return number indicator of how many times has the wrapped value changed
     */
    default long changeVersion() {
        return versionedValue().versionNumber;
    }

    /**
     * @return current {@code ChangingValue}'s wrapped {@code FailableValue}
     */
    default FailableValue<T> failableValue() {
        return versionedValue().failableValue();
    }

    /**
     * Generates a value using the current {@code ChangingValue}'s wrapped value
     *
     * @param valueMapper function that is applied to currently wrapped value
     * @param <T2>        type of generated value
     * @param <E>         {@link Throwable} type, in case the {@code valueMapper} function should throw an {@link Throwable}
     * @return generated value
     * @throws E exception generated by {@code valueMapper} function
     */
    default <T2, E extends Throwable> T2 mapToValue(ValueMapper<? super T, ? extends T2, E> valueMapper) throws E {
        return valueMapper.map(value());
    }

    /**
     * Executes {@code valueHandler} function for currently wrapped value
     *
     * @param valueHandler function that is executed for currently wrapped value
     * @param <E>          {@link Throwable} type, in case the {@code valueHandler} function should throw an {@link Throwable}
     * @throws E exception generated by {@code valueHandler} function
     */
    default <E extends Throwable> void forCurrentValue(ValueHandler<? super T, ? extends E> valueHandler) throws E {
        valueHandler.handle(value());
    }
}
